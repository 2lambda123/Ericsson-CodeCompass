/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Thrift;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;
using Thrift.Transport;
using Thrift.Transport.Client;
using Thrift.Transport.Server;
using Thrift.Processor;


public partial class ProjectService
{
  public interface IAsync
  {
    Task<FileInfo> getFileInfoAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<FileInfo> getFileInfoByPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken));

    Task<string> getFileContentAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<FileInfo> getParentAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<FileInfo>> getRootFilesAsync(CancellationToken cancellationToken = default(CancellationToken));

    Task<List<FileInfo>> getChildFilesAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<FileInfo>> getSubtreeAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<FileInfo>> getOpenTreeTillFileAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<FileInfo>> getPathTillFileAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<BuildLog>> getBuildLogAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<FileInfo>> searchFileAsync(string text, bool onlyFile, CancellationToken cancellationToken = default(CancellationToken));

    Task<List<StatisticsInfo>> getStatisticsAsync(CancellationToken cancellationToken = default(CancellationToken));

    Task<List<string>> getFileTypesAsync(CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// This function returns with project labels which was added in parse time.
    /// It reads the labels from the labels.txt file which is located in the
    /// workspace data directory in an INI-like format.
    /// </summary>
    Task<Dictionary<string, string>> getLabelsAsync(CancellationToken cancellationToken = default(CancellationToken));

  }


  public class Client : TBaseClient, IDisposable, IAsync
  {
    public Client(TProtocol protocol) : this(protocol, protocol)
    {
    }

    public Client(TProtocol inputProtocol, TProtocol outputProtocol) : base(inputProtocol, outputProtocol)    {
    }
    public async Task<FileInfo> getFileInfoAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getFileInfo", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getFileInfoArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getFileInfoResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.ex)
      {
        throw result.Ex;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getFileInfo failed: unknown result");
    }

    public async Task<FileInfo> getFileInfoByPathAsync(string path, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getFileInfoByPath", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getFileInfoByPathArgs();
      args.Path = path;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getFileInfoByPathResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.ex)
      {
        throw result.Ex;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getFileInfoByPath failed: unknown result");
    }

    public async Task<string> getFileContentAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getFileContent", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getFileContentArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getFileContentResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.ex)
      {
        throw result.Ex;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getFileContent failed: unknown result");
    }

    public async Task<FileInfo> getParentAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getParent", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getParentArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getParentResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.ex)
      {
        throw result.Ex;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getParent failed: unknown result");
    }

    public async Task<List<FileInfo>> getRootFilesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getRootFiles", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getRootFilesArgs();
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getRootFilesResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRootFiles failed: unknown result");
    }

    public async Task<List<FileInfo>> getChildFilesAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getChildFiles", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getChildFilesArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getChildFilesResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getChildFiles failed: unknown result");
    }

    public async Task<List<FileInfo>> getSubtreeAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getSubtree", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getSubtreeArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getSubtreeResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getSubtree failed: unknown result");
    }

    public async Task<List<FileInfo>> getOpenTreeTillFileAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getOpenTreeTillFile", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getOpenTreeTillFileArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getOpenTreeTillFileResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getOpenTreeTillFile failed: unknown result");
    }

    public async Task<List<FileInfo>> getPathTillFileAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getPathTillFile", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getPathTillFileArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getPathTillFileResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getPathTillFile failed: unknown result");
    }

    public async Task<List<BuildLog>> getBuildLogAsync(string fileId, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getBuildLog", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getBuildLogArgs();
      args.FileId = fileId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getBuildLogResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getBuildLog failed: unknown result");
    }

    public async Task<List<FileInfo>> searchFileAsync(string text, bool onlyFile, CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("searchFile", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new searchFileArgs();
      args.Text = text;
      args.OnlyFile = onlyFile;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new searchFileResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "searchFile failed: unknown result");
    }

    public async Task<List<StatisticsInfo>> getStatisticsAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getStatistics", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getStatisticsArgs();
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getStatisticsResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getStatistics failed: unknown result");
    }

    public async Task<List<string>> getFileTypesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getFileTypes", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getFileTypesArgs();
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getFileTypesResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getFileTypes failed: unknown result");
    }

    public async Task<Dictionary<string, string>> getLabelsAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getLabels", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getLabelsArgs();
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getLabelsResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getLabels failed: unknown result");
    }

  }

  public class AsyncProcessor : ITAsyncProcessor
  {
    private IAsync _iAsync;

    public AsyncProcessor(IAsync iAsync)
    {
      if (iAsync == null) throw new ArgumentNullException(nameof(iAsync));

      _iAsync = iAsync;
      processMap_["getFileInfo"] = getFileInfo_ProcessAsync;
      processMap_["getFileInfoByPath"] = getFileInfoByPath_ProcessAsync;
      processMap_["getFileContent"] = getFileContent_ProcessAsync;
      processMap_["getParent"] = getParent_ProcessAsync;
      processMap_["getRootFiles"] = getRootFiles_ProcessAsync;
      processMap_["getChildFiles"] = getChildFiles_ProcessAsync;
      processMap_["getSubtree"] = getSubtree_ProcessAsync;
      processMap_["getOpenTreeTillFile"] = getOpenTreeTillFile_ProcessAsync;
      processMap_["getPathTillFile"] = getPathTillFile_ProcessAsync;
      processMap_["getBuildLog"] = getBuildLog_ProcessAsync;
      processMap_["searchFile"] = searchFile_ProcessAsync;
      processMap_["getStatistics"] = getStatistics_ProcessAsync;
      processMap_["getFileTypes"] = getFileTypes_ProcessAsync;
      processMap_["getLabels"] = getLabels_ProcessAsync;
    }

    protected delegate Task ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken);
    protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

    public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot)
    {
      return await ProcessAsync(iprot, oprot, CancellationToken.None);
    }

    public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      try
      {
        var msg = await iprot.ReadMessageBeginAsync(cancellationToken);

        ProcessFunction fn;
        processMap_.TryGetValue(msg.Name, out fn);

        if (fn == null)
        {
          await TProtocolUtil.SkipAsync(iprot, TType.Struct, cancellationToken);
          await iprot.ReadMessageEndAsync(cancellationToken);
          var x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
          await oprot.WriteMessageBeginAsync(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID), cancellationToken);
          await x.WriteAsync(oprot, cancellationToken);
          await oprot.WriteMessageEndAsync(cancellationToken);
          await oprot.Transport.FlushAsync(cancellationToken);
          return true;
        }

        await fn(msg.SeqID, iprot, oprot, cancellationToken);

      }
      catch (IOException)
      {
        return false;
      }

      return true;
    }

    public async Task getFileInfo_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getFileInfoArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getFileInfoResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getFileInfoAsync(args.FileId, cancellationToken);
        }
        catch (InvalidId ex)
        {
          result.Ex = ex;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getFileInfo", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getFileInfo", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getFileInfoByPath_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getFileInfoByPathArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getFileInfoByPathResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getFileInfoByPathAsync(args.Path, cancellationToken);
        }
        catch (InvalidInput ex)
        {
          result.Ex = ex;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getFileInfoByPath", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getFileInfoByPath", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getFileContent_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getFileContentArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getFileContentResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getFileContentAsync(args.FileId, cancellationToken);
        }
        catch (InvalidId ex)
        {
          result.Ex = ex;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getFileContent", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getFileContent", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getParent_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getParentArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getParentResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getParentAsync(args.FileId, cancellationToken);
        }
        catch (InvalidId ex)
        {
          result.Ex = ex;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getParent", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getParent", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getRootFiles_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getRootFilesArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getRootFilesResult();
      try
      {
        result.Success = await _iAsync.getRootFilesAsync(cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getRootFiles", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getRootFiles", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getChildFiles_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getChildFilesArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getChildFilesResult();
      try
      {
        result.Success = await _iAsync.getChildFilesAsync(args.FileId, cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getChildFiles", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getChildFiles", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getSubtree_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getSubtreeArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getSubtreeResult();
      try
      {
        result.Success = await _iAsync.getSubtreeAsync(args.FileId, cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getSubtree", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getSubtree", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getOpenTreeTillFile_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getOpenTreeTillFileArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getOpenTreeTillFileResult();
      try
      {
        result.Success = await _iAsync.getOpenTreeTillFileAsync(args.FileId, cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getOpenTreeTillFile", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getOpenTreeTillFile", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getPathTillFile_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getPathTillFileArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getPathTillFileResult();
      try
      {
        result.Success = await _iAsync.getPathTillFileAsync(args.FileId, cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getPathTillFile", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getPathTillFile", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getBuildLog_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getBuildLogArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getBuildLogResult();
      try
      {
        result.Success = await _iAsync.getBuildLogAsync(args.FileId, cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getBuildLog", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getBuildLog", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task searchFile_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new searchFileArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new searchFileResult();
      try
      {
        result.Success = await _iAsync.searchFileAsync(args.Text, args.OnlyFile, cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("searchFile", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("searchFile", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getStatistics_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getStatisticsArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getStatisticsResult();
      try
      {
        result.Success = await _iAsync.getStatisticsAsync(cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getStatistics", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getStatistics", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getFileTypes_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getFileTypesArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getFileTypesResult();
      try
      {
        result.Success = await _iAsync.getFileTypesAsync(cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getFileTypes", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getFileTypes", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getLabels_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getLabelsArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getLabelsResult();
      try
      {
        result.Success = await _iAsync.getLabelsAsync(cancellationToken);
        await oprot.WriteMessageBeginAsync(new TMessage("getLabels", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getLabels", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

  }


  public partial class getFileInfoArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getFileInfoArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileInfo_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileInfoArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileInfo_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileInfoResult : TBase
  {
    private FileInfo _success;
    private InvalidId _ex;

    public FileInfo Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public InvalidId Ex
    {
      get
      {
        return _ex;
      }
      set
      {
        __isset.ex = true;
        this._ex = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool ex;
    }

    public getFileInfoResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new FileInfo();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Ex = new InvalidId();
                await Ex.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileInfo_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.ex)
        {
          if (Ex != null)
          {
            field.Name = "Ex";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Ex.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileInfoResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (System.Object.Equals(Success, other.Success))))
        && ((__isset.ex == other.__isset.ex) && ((!__isset.ex) || (System.Object.Equals(Ex, other.Ex))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + Success.GetHashCode();
        if(__isset.ex)
          hashcode = (hashcode * 397) + Ex.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileInfo_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Ex != null && __isset.ex)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Ex: ");
        sb.Append(Ex== null ? "<null>" : Ex.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileInfoByPathArgs : TBase
  {
    private string _path;

    public string Path
    {
      get
      {
        return _path;
      }
      set
      {
        __isset.path = true;
        this._path = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool path;
    }

    public getFileInfoByPathArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Path = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileInfoByPath_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (Path != null && __isset.path)
        {
          field.Name = "path";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(Path, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileInfoByPathArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.path == other.__isset.path) && ((!__isset.path) || (System.Object.Equals(Path, other.Path))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.path)
          hashcode = (hashcode * 397) + Path.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileInfoByPath_args(");
      bool __first = true;
      if (Path != null && __isset.path)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Path: ");
        sb.Append(Path);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileInfoByPathResult : TBase
  {
    private FileInfo _success;
    private InvalidInput _ex;

    public FileInfo Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public InvalidInput Ex
    {
      get
      {
        return _ex;
      }
      set
      {
        __isset.ex = true;
        this._ex = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool ex;
    }

    public getFileInfoByPathResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new FileInfo();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Ex = new InvalidInput();
                await Ex.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileInfoByPath_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.ex)
        {
          if (Ex != null)
          {
            field.Name = "Ex";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Ex.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileInfoByPathResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (System.Object.Equals(Success, other.Success))))
        && ((__isset.ex == other.__isset.ex) && ((!__isset.ex) || (System.Object.Equals(Ex, other.Ex))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + Success.GetHashCode();
        if(__isset.ex)
          hashcode = (hashcode * 397) + Ex.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileInfoByPath_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Ex != null && __isset.ex)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Ex: ");
        sb.Append(Ex== null ? "<null>" : Ex.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileContentArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getFileContentArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileContent_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileContentArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileContent_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileContentResult : TBase
  {
    private string _success;
    private InvalidId _ex;

    public string Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public InvalidId Ex
    {
      get
      {
        return _ex;
      }
      set
      {
        __isset.ex = true;
        this._ex = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool ex;
    }

    public getFileContentResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.String)
              {
                Success = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Ex = new InvalidId();
                await Ex.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileContent_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.String;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await oprot.WriteStringAsync(Success, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.ex)
        {
          if (Ex != null)
          {
            field.Name = "Ex";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Ex.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileContentResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (System.Object.Equals(Success, other.Success))))
        && ((__isset.ex == other.__isset.ex) && ((!__isset.ex) || (System.Object.Equals(Ex, other.Ex))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + Success.GetHashCode();
        if(__isset.ex)
          hashcode = (hashcode * 397) + Ex.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileContent_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Ex != null && __isset.ex)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Ex: ");
        sb.Append(Ex== null ? "<null>" : Ex.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getParentArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getParentArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getParent_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getParentArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getParent_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getParentResult : TBase
  {
    private FileInfo _success;
    private InvalidId _ex;

    public FileInfo Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public InvalidId Ex
    {
      get
      {
        return _ex;
      }
      set
      {
        __isset.ex = true;
        this._ex = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool ex;
    }

    public getParentResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new FileInfo();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Ex = new InvalidId();
                await Ex.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getParent_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.ex)
        {
          if (Ex != null)
          {
            field.Name = "Ex";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Ex.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getParentResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (System.Object.Equals(Success, other.Success))))
        && ((__isset.ex == other.__isset.ex) && ((!__isset.ex) || (System.Object.Equals(Ex, other.Ex))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + Success.GetHashCode();
        if(__isset.ex)
          hashcode = (hashcode * 397) + Ex.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getParent_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Ex != null && __isset.ex)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Ex: ");
        sb.Append(Ex== null ? "<null>" : Ex.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getRootFilesArgs : TBase
  {

    public getRootFilesArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getRootFiles_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getRootFilesArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getRootFiles_args(");
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getRootFilesResult : TBase
  {
    private List<FileInfo> _success;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getRootFilesResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list0 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<FileInfo>(_list0.Count);
                  for(int _i1 = 0; _i1 < _list0.Count; ++_i1)
                  {
                    FileInfo _elem2;
                    _elem2 = new FileInfo();
                    await _elem2.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem2);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getRootFiles_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (FileInfo _iter3 in Success)
              {
                await _iter3.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getRootFilesResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getRootFiles_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getChildFilesArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getChildFilesArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getChildFiles_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getChildFilesArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getChildFiles_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getChildFilesResult : TBase
  {
    private List<FileInfo> _success;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getChildFilesResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list4 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<FileInfo>(_list4.Count);
                  for(int _i5 = 0; _i5 < _list4.Count; ++_i5)
                  {
                    FileInfo _elem6;
                    _elem6 = new FileInfo();
                    await _elem6.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem6);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getChildFiles_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (FileInfo _iter7 in Success)
              {
                await _iter7.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getChildFilesResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getChildFiles_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getSubtreeArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getSubtreeArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getSubtree_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getSubtreeArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getSubtree_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getSubtreeResult : TBase
  {
    private List<FileInfo> _success;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getSubtreeResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list8 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<FileInfo>(_list8.Count);
                  for(int _i9 = 0; _i9 < _list8.Count; ++_i9)
                  {
                    FileInfo _elem10;
                    _elem10 = new FileInfo();
                    await _elem10.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem10);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getSubtree_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (FileInfo _iter11 in Success)
              {
                await _iter11.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getSubtreeResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getSubtree_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getOpenTreeTillFileArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getOpenTreeTillFileArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getOpenTreeTillFile_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getOpenTreeTillFileArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getOpenTreeTillFile_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getOpenTreeTillFileResult : TBase
  {
    private List<FileInfo> _success;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getOpenTreeTillFileResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list12 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<FileInfo>(_list12.Count);
                  for(int _i13 = 0; _i13 < _list12.Count; ++_i13)
                  {
                    FileInfo _elem14;
                    _elem14 = new FileInfo();
                    await _elem14.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem14);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getOpenTreeTillFile_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (FileInfo _iter15 in Success)
              {
                await _iter15.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getOpenTreeTillFileResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getOpenTreeTillFile_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getPathTillFileArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getPathTillFileArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getPathTillFile_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getPathTillFileArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getPathTillFile_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getPathTillFileResult : TBase
  {
    private List<FileInfo> _success;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getPathTillFileResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list16 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<FileInfo>(_list16.Count);
                  for(int _i17 = 0; _i17 < _list16.Count; ++_i17)
                  {
                    FileInfo _elem18;
                    _elem18 = new FileInfo();
                    await _elem18.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem18);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getPathTillFile_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (FileInfo _iter19 in Success)
              {
                await _iter19.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getPathTillFileResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getPathTillFile_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getBuildLogArgs : TBase
  {
    private string _fileId;

    public string FileId
    {
      get
      {
        return _fileId;
      }
      set
      {
        __isset.fileId = true;
        this._fileId = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool fileId;
    }

    public getBuildLogArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                FileId = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getBuildLog_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (FileId != null && __isset.fileId)
        {
          field.Name = "fileId";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(FileId, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getBuildLogArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.fileId == other.__isset.fileId) && ((!__isset.fileId) || (System.Object.Equals(FileId, other.FileId))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.fileId)
          hashcode = (hashcode * 397) + FileId.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getBuildLog_args(");
      bool __first = true;
      if (FileId != null && __isset.fileId)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("FileId: ");
        sb.Append(FileId);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getBuildLogResult : TBase
  {
    private List<BuildLog> _success;

    public List<BuildLog> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getBuildLogResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list20 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<BuildLog>(_list20.Count);
                  for(int _i21 = 0; _i21 < _list20.Count; ++_i21)
                  {
                    BuildLog _elem22;
                    _elem22 = new BuildLog();
                    await _elem22.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem22);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getBuildLog_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (BuildLog _iter23 in Success)
              {
                await _iter23.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getBuildLogResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getBuildLog_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class searchFileArgs : TBase
  {
    private string _text;
    private bool _onlyFile;

    public string Text
    {
      get
      {
        return _text;
      }
      set
      {
        __isset.text = true;
        this._text = value;
      }
    }

    public bool OnlyFile
    {
      get
      {
        return _onlyFile;
      }
      set
      {
        __isset.onlyFile = true;
        this._onlyFile = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool text;
      public bool onlyFile;
    }

    public searchFileArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Text = await iprot.ReadStringAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Bool)
              {
                OnlyFile = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("searchFile_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        if (Text != null && __isset.text)
        {
          field.Name = "text";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(Text, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if (__isset.onlyFile)
        {
          field.Name = "onlyFile";
          field.Type = TType.Bool;
          field.ID = 2;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBoolAsync(OnlyFile, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as searchFileArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.text == other.__isset.text) && ((!__isset.text) || (System.Object.Equals(Text, other.Text))))
        && ((__isset.onlyFile == other.__isset.onlyFile) && ((!__isset.onlyFile) || (System.Object.Equals(OnlyFile, other.OnlyFile))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.text)
          hashcode = (hashcode * 397) + Text.GetHashCode();
        if(__isset.onlyFile)
          hashcode = (hashcode * 397) + OnlyFile.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("searchFile_args(");
      bool __first = true;
      if (Text != null && __isset.text)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Text: ");
        sb.Append(Text);
      }
      if (__isset.onlyFile)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("OnlyFile: ");
        sb.Append(OnlyFile);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class searchFileResult : TBase
  {
    private List<FileInfo> _success;

    public List<FileInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public searchFileResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list24 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<FileInfo>(_list24.Count);
                  for(int _i25 = 0; _i25 < _list24.Count; ++_i25)
                  {
                    FileInfo _elem26;
                    _elem26 = new FileInfo();
                    await _elem26.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem26);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("searchFile_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (FileInfo _iter27 in Success)
              {
                await _iter27.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as searchFileResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("searchFile_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getStatisticsArgs : TBase
  {

    public getStatisticsArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getStatistics_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getStatisticsArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getStatistics_args(");
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getStatisticsResult : TBase
  {
    private List<StatisticsInfo> _success;

    public List<StatisticsInfo> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getStatisticsResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list28 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<StatisticsInfo>(_list28.Count);
                  for(int _i29 = 0; _i29 < _list28.Count; ++_i29)
                  {
                    StatisticsInfo _elem30;
                    _elem30 = new StatisticsInfo();
                    await _elem30.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem30);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getStatistics_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (StatisticsInfo _iter31 in Success)
              {
                await _iter31.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getStatisticsResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getStatistics_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileTypesArgs : TBase
  {

    public getFileTypesArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileTypes_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileTypesArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileTypes_args(");
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getFileTypesResult : TBase
  {
    private List<string> _success;

    public List<string> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getFileTypesResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  TList _list32 = await iprot.ReadListBeginAsync(cancellationToken);
                  Success = new List<string>(_list32.Count);
                  for(int _i33 = 0; _i33 < _list32.Count; ++_i33)
                  {
                    string _elem34;
                    _elem34 = await iprot.ReadStringAsync(cancellationToken);
                    Success.Add(_elem34);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getFileTypes_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.String, Success.Count), cancellationToken);
              foreach (string _iter35 in Success)
              {
                await oprot.WriteStringAsync(_iter35, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getFileTypesResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getFileTypes_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getLabelsArgs : TBase
  {

    public getLabelsArgs()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getLabels_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getLabelsArgs;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return true;
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getLabels_args(");
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getLabelsResult : TBase
  {
    private Dictionary<string, string> _success;

    public Dictionary<string, string> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
    }

    public getLabelsResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Map)
              {
                {
                  TMap _map36 = await iprot.ReadMapBeginAsync(cancellationToken);
                  Success = new Dictionary<string, string>(_map36.Count);
                  for(int _i37 = 0; _i37 < _map36.Count; ++_i37)
                  {
                    string _key38;
                    string _val39;
                    _key38 = await iprot.ReadStringAsync(cancellationToken);
                    _val39 = await iprot.ReadStringAsync(cancellationToken);
                    Success[_key38] = _val39;
                  }
                  await iprot.ReadMapEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getLabels_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Map;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteMapBeginAsync(new TMap(TType.String, TType.String, Success.Count), cancellationToken);
              foreach (string _iter40 in Success.Keys)
              {
                await oprot.WriteStringAsync(_iter40, cancellationToken);
                await oprot.WriteStringAsync(Success[_iter40], cancellationToken);
              }
              await oprot.WriteMapEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as getLabelsResult;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return ((__isset.success == other.__isset.success) && ((!__isset.success) || (TCollections.Equals(Success, other.Success))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        if(__isset.success)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Success);
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getLabels_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }

}
